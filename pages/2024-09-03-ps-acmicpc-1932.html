<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/dff90bb72ab001f4.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-04b47019326c343d.js"/><script src="/_next/static/chunks/4bd1b696-5b6c0ccbd3c0c9ab.js" async=""></script><script src="/_next/static/chunks/684-91835b1cd9d457e6.js" async=""></script><script src="/_next/static/chunks/main-app-fdce7a7a567e1145.js" async=""></script><meta name="next-size-adjust" content=""/><title>Create Next App</title><meta name="description" content="Generated by create next app"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b"><h1>1932 - 정수 삼각형</h1>
<blockquote>
<p>문제 원문: https://www.acmicpc.net/problem/1932</p>
</blockquote>
<h2>풀이</h2>
<p>이 문제에서, 가장 합이 최대가 되는 경로를 구하는 프로그램을 작성하기 위해서는,
모든 경우의 수를 고려해야 합니다. 이전의 선택이 이후의 선택에서의 선택지에
영향을 주기 때문에, Greedy Algorithm을 사용할 수는 없습니다. 따라서, 모든 경우의
수를 효율적으로 고려하기 위해, Dynamic Programming을 사용하면 해결할 수 잇을
것으로 예측 가능합니다.</p>
<p>우선, 요구사항에 맞는 점화식을 작성합니다.</p>
<blockquote>
<p>리스트에 접근할 때, Index가 범위 밖에 잇을 경우 -1을 반환하는 함수를 <code>zero()</code>,
값을 여러개 받았을 때, 가장 최대의 값을 반환하는 함수를 <code>max()</code>라고 하고,</p>
<p><code>i</code>를 선택한 높이, <code>j</code>를 해당 높이에서의 트리의 index라고 하였을 때, 트리의
값을 <code>v[i][j]</code>, 최대 값을 <code>dp[i][j]</code>라고 하면,</p>
<p><code>dp[i][j] = max(zero(dp[i-1][j-1]), zero(dp[i-1][j])) + v[i][j]</code>의 관계가 성립</p>
<p>풀어서 말하자면, <code>i</code>번째 높이에서 <code>j</code>번째 index를 선택했을 때의 최대 합은,
<code>i-1</code>번째 높이에서 <code>j-1</code>번째 index를 선택했을 때의 최대 합과, <code>i-1</code>번째
높이에서 <code>j</code>번째 index를 선택했을 때의 최대 합 중, 더 큰 값에 현재 높이의 값을
더한 값이라고 할 수 있습니다.</p>
</blockquote>
<p>이제, 이 점화식을 코드로 구현하면 됩니다.</p>
<pre><code class="language-python">I = input
O = print

from typing import TypeVar

# DP를 사용하여 해결
depth = int(I())

tree: list[list[int]] = [[i for i in map(lambda x: int(x), I().split(&quot; &quot;))] for _ in range(depth)]

memory: list[list[int]] = []

T = TypeVar(&quot;T&quot;)
def getOrNone(list: list[T], idx: int) -&gt; T | None:
    if idx &lt; 0 or idx &gt;= len(list):
        return None
    else:
        return list[idx]

# i번째 depth의 t번째 노드에 도착했을 때의 최대 기대값을 c[i][t] 라고 하고,
# 해당 트리의 i번째 depth의 t번째 노드의 값을 v[i][t]라고 할 때
# c[i][t] = max(c[i-1][t-1], c[i-1],[t]) + v[i][t]

for currentDpt in range(depth):
    toMemory = [0 for _ in range(len(tree[currentDpt]))]
    for idx, value in enumerate(tree[currentDpt]):
        memvalue_a = getOrNone(getOrNone(memory, currentDpt-1) or [], idx - 1) or 0
        memvalue_b = getOrNone(getOrNone(memory, currentDpt-1) or [], idx) or 0
        toMemory[idx] = max(memvalue_a, memvalue_b) + value
    memory.append(toMemory)

O(max(memory.pop()))
</code></pre><script src="/_next/static/chunks/webpack-04b47019326c343d.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[7555,[],\"\"]\n3:I[1295,[],\"\"]\n4:I[9665,[],\"OutletBoundary\"]\n7:I[9665,[],\"ViewportBoundary\"]\n9:I[9665,[],\"MetadataBoundary\"]\nb:I[6614,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/dff90bb72ab001f4.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"STDKdyjWtCfHyninl32o3\",\"p\":\"\",\"c\":[\"\",\"pages\",\"2024-09-03-ps-acmicpc-1932\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"pages\",{\"children\":[\"2024-09-03-ps-acmicpc-1932\",{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/dff90bb72ab001f4.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"pages\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"2024-09-03-ps-acmicpc-1932\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"h1\",null,{\"children\":\"1932 - 정수 삼각형\"}],\"\\n\",[\"$\",\"blockquote\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":\"문제 원문: https://www.acmicpc.net/problem/1932\"}],\"\\n\"]}],\"\\n\",[\"$\",\"h2\",null,{\"children\":\"풀이\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"이 문제에서, 가장 합이 최대가 되는 경로를 구하는 프로그램을 작성하기 위해서는,\\n모든 경우의 수를 고려해야 합니다. 이전의 선택이 이후의 선택에서의 선택지에\\n영향을 주기 때문에, Greedy Algorithm을 사용할 수는 없습니다. 따라서, 모든 경우의\\n수를 효율적으로 고려하기 위해, Dynamic Programming을 사용하면 해결할 수 잇을\\n것으로 예측 가능합니다.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"우선, 요구사항에 맞는 점화식을 작성합니다.\"}],\"\\n\",[\"$\",\"blockquote\",null,{\"children\":[\"\\n\",[\"$\",\"p\",null,{\"children\":[\"리스트에 접근할 때, Index가 범위 밖에 잇을 경우 -1을 반환하는 함수를 \",[\"$\",\"code\",null,{\"children\":\"zero()\"}],\",\\n값을 여러개 받았을 때, 가장 최대의 값을 반환하는 함수를 \",[\"$\",\"code\",null,{\"children\":\"max()\"}],\"라고 하고,\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"i\"}],\"를 선택한 높이, \",[\"$\",\"code\",null,{\"children\":\"j\"}],\"를 해당 높이에서의 트리의 index라고 하였을 때, 트리의\\n값을 \",[\"$\",\"code\",null,{\"children\":\"v[i][j]\"}],\", 최대 값을 \",[\"$\",\"code\",null,{\"children\":\"dp[i][j]\"}],\"라고 하면,\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"code\",null,{\"children\":\"dp[i][j] = max(zero(dp[i-1][j-1]), zero(dp[i-1][j])) + v[i][j]\"}],\"의 관계가 성립\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"풀어서 말하자면, \",[\"$\",\"code\",null,{\"children\":\"i\"}],\"번째 높이에서 \",[\"$\",\"code\",null,{\"children\":\"j\"}],\"번째 index를 선택했을 때의 최대 합은,\\n\",[\"$\",\"code\",null,{\"children\":\"i-1\"}],\"번째 높이에서 \",[\"$\",\"code\",null,{\"children\":\"j-1\"}],\"번째 index를 선택했을 때의 최대 합과, \",[\"$\",\"code\",null,{\"children\":\"i-1\"}],\"번째\\n높이에서 \",[\"$\",\"code\",null,{\"children\":\"j\"}],\"번째 index를 선택했을 때의 최대 합 중, 더 큰 값에 현재 높이의 값을\\n더한 값이라고 할 수 있습니다.\"]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"이제, 이 점화식을 코드로 구현하면 됩니다.\"}],\"\\n\",[\"$\",\"pre\",null,{\"children\":[\"$\",\"code\",null,{\"className\":\"language-python\",\"children\":\"I = input\\nO = print\\n\\nfrom typing import TypeVar\\n\\n# DP를 사용하여 해결\\ndepth = int(I())\\n\\ntree: list[list[int]] = [[i for i in map(lambda x: int(x), I().split(\\\" \\\"))] for _ in range(depth)]\\n\\nmemory: list[list[int]] = []\\n\\nT = TypeVar(\\\"T\\\")\\ndef getOrNone(list: list[T], idx: int) -\u003e T | None:\\n    if idx \u003c 0 or idx \u003e= len(list):\\n        return None\\n    else:\\n        return list[idx]\\n\\n# i번째 depth의 t번째 노드에 도착했을 때의 최대 기대값을 c[i][t] 라고 하고,\\n# 해당 트리의 i번째 depth의 t번째 노드의 값을 v[i][t]라고 할 때\\n# c[i][t] = max(c[i-1][t-1], c[i-1],[t]) + v[i][t]\\n\\nfor currentDpt in range(depth):\\n    toMemory = [0 for _ in range(len(tree[currentDpt]))]\\n    for idx, value in enumerate(tree[currentDpt]):\\n        memvalue_a = getOrNone(getOrNone(memory, currentDpt-1) or [], idx - 1) or 0\\n        memvalue_b = getOrNone(getOrNone(memory, currentDpt-1) or [], idx) or 0\\n        toMemory[idx] = max(memvalue_a, memvalue_b) + value\\n    memory.append(toMemory)\\n\\nO(max(memory.pop()))\\n\"}]}]],\"$undefined\",null,[\"$\",\"$L4\",null,{\"children\":[\"$L5\",\"$L6\",null]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"P5PTDtd_VeIP_PLe6mZti\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n5:null\n"])</script><script>self.__next_f.push([1,"6:null\na:[[\"$\",\"title\",\"0\",{\"children\":\"Create Next App\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Generated by create next app\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script></body></html>